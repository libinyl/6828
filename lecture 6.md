# Lecture 6: Virtual Memory

## 概览

**问题:**  如果某个应用程序(如shell)有个恐怖的 bug,可能会向某个随机内存地址写入值.如何保护内核/其他进程不被破坏?

**解决思路:** 把每个进程隔离,让它们有自己的独立空间.它们可以读写自己的内存,但不能读写其他进程的内存.

**实现难点:**  我们只有一块物理内存,如何建立多个虚拟内存,还得隔离它们?

**硬件条件:**  x86 提供了分页机制,可以解决上述问题.

**分页功能:**  引入了一个中间层.原本是 CPU 不直接物理内存寻址,而是经过 MMU 的翻译,把虚拟地址翻译为物理地址.

- 软件只能读写虚拟地址,不能读写独立地址.
- **MMU:**  维护一个表, 把虚拟地址映射至物理地址.这个表称为`page table`.

**虚拟地址的数位**, x86 把物理地址每 4KB=4096Byte 分一页,4096=0x1000,即用低 12 位数即可表示这些页的索引. 而虚拟地址是 32 位,所以把地址的前 20 位看做每个page table 的索引.

如果要维护这 20 位,需要多大的数组?

用 int 类型来存储的话,就是 2^20*32bits = 2^20*4Bytes = 4MB.太大了! 一个数组 4MB,难以接受.早期电脑没这么大内存! 引入:二级页表.即 page directory.

**page directory:** 分页再分页.

一级页表：每 4KB(0x1000) 分一页，一共可以分 0x100000000/0x1000=0x100000(4MB)页

二级页表：把一级页表每 4KB 分一页，一共可以分 4MB/4KB=1024页 1024 页需要 10 个 bit 来表示.所以再向前借 10 位.现在一共借用了 12+10=22 位.

2<sup>32</sup> = 2<sup>10</sup> x 2<sup>10</sup> x 2<sup>12</sup>  
=1024 x 1024 x 2<sup>12</sup>  
=1024 x 1024 x 4096

所以对于一个虚拟地址 va 来说,高 10 位是一级索引,也就是 page directory的索引值,中 10 位是二级索引,也就是 page table 的索引值,最后 12 位是页内索引,在 page 内部找到具体的地址

所以其实可以说是一个二维数组(多叉树结构).

**如何构造 page directory 和 page table?**

它们都是 1024 大小的数组,每个数组的元素就是一个整数,用于存储地址.但是int 类型整数是 32 位,而用 page directory 来查找 page table 时只需用到 10 位(因为只有 1024 个 table),空出来 12 位.这 12 位我们用作是标志位,用以表明权限等信息.

```
phaddr(va) = pd[va >> 22][va >> 12 & 0x3ff][va & 0xfff]
```














